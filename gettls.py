from scapy.all import *
from datetime import datetime
import pandas as pd
from scipy import stats
import joblib

class TLSPcapDecode:
    try :
        data = joblib.load('data/cs_ext_dict')
    except:
        #traceback.print_exc()
        data={'cs':{},'ext':{}}
            
    # 解析以太网层协议
    def ether_decode(self, p):
        ether_data = dict()
        if p.haslayer("Ether"):
            # p.time -> 毫秒时间戳
            ether_data['time'] = datetime.fromtimestamp(float(p.time)).strftime('%Y-%m-%d %H:%M:%S.%f')
            ether_data['len'] = len(corrupt_bytes(p))
            # ether_data['info'] = p.summary()
            if p.haslayer("IP"):
                ether_data['IP'] = self.ip_decode(p)
            # 赋给类公有变量
        else:
            ether_data['ether_error'] = False
        return ether_data

    # 解析IP层协议
    def ip_decode(self, p):
        ip_data = dict()
        if p.haslayer("IP"):
            ip = p.getlayer("IP")
            ip_data['sa'] = ip.src
            ip_data['da'] = ip.dst
            ip_data['sp'] = ip.sport
            ip_data['dp'] = ip.dport
            if p.haslayer("TCP"):
                ip_data['TCP'] = self.tcp_decode(p, ip)
                return ip_data
        else:
            ip_data['ip_error'] = False
            return ip_data

    # 解析TCP层协议
    def tcp_decode(self, p, ip):
        tcp_data = dict()
        if p.haslayer("TCP"):
            tcp = p.getlayer("TCP")
            payload = tcp.payload
            bts=[]
            if len(payload):
                bts = hexdump(payload,True).split("\n")
                bts=list(map(lambda x: x[6:54].strip(),bts))
                bts=" ".join(bts).split(' ')
            tcp_data['bytes']=bts
            # tcp.show()
            # 此处非TLS，而是SSL/TLS
            if p.haslayer("SSL/TLS"):
                tcp_data['TLS'] = self.tls_decode(p, ip, tcp)
                return tcp_data
            else:
                return tcp_data
        else:
            tcp_data['tcp_error'] = False
            return tcp_data

    # 解析TLS协议
    def tls_decode(self, p, ip, tcp):
        tls_data = dict()
        if p.haslayer("SSL/TLS"):
            tls = p.getlayer("SSL/TLS")
            #time.sleep(1)
            # ls(tls)
            # tls.show()
            # tls version TLS 1.2 0x0303 -> 771
            #tls_data['tls_vers'] = tls['TLS Record'].version
            # get tls length
            try:
                tls_data['tls_len'] = tls['TLS Record'].length
            except:
                #traceback.print_exc()
                tls_data['tls_error'] = False
                return tls_data
            # get tls duration
            # get ssl/tls stage 2 info
            try:
                tls['TLS Handshake']
            except IndexError:
                #traceback.print_exc()
                tls_data['tls_step'] = -1
            else:
                try:
                    tls_data['tls_step'] = tls['TLS Handshake'].type
                    #client hello
                    if tls_data['tls_step'] == 1:
                        tls_data['cs']=tls['TLS Handshake'].cipher_suites
                        #print(tls_data['cs'])
                        tls_data['num_of_exts']=len(tls['TLS Handshake'].extensions)
                        c_extensions=[]
                        for ext in tls['TLS Handshake'].extensions:
                            c_extensions.append(ext.type)
                        tls_data['c_extensions']=c_extensions
                    #print(c_extensions)
                # stage 2: Server Hello
                    elif tls_data['tls_step'] == 2:
                    # tls cipher ECDHE_RSA_WITH_AES_128_CBC_SHA256 0xc027 -> 49191
                        tls_data['tls_cip'] = tls['TLS Handshake'].cipher_suite
                        # tls compression method 0x00 -> 0
                        tls_data['tls_comp'] = tls['TLS Handshake'].compression_method
                        # tls extensions length 0x8 -> 8
                        tls_data['tls_extlen'] = tls['TLS Handshake'].extensions_length
                        # tls extensions type 0x000b -> 11
                        tls_data['tls_exttype'] = tls['TLS Extension'].type
                except:
                    #traceback.print_exc()
                    tls_data['tls_error'] = False
            return tls_data
        else:
            tls_data['tls_error'] = False
            return tls_data

        
    def update_data(self,tls):
        updated = False
        data=self.data
        for ext in tls['c_extensions']:
            if ext not in data['ext'] :
                updated = True
                data['ext'][ext] = "ext_" + str(ext)
        for cs in tls['cs']:
            if cs not in data['cs'] :
                updated = True
                data['cs'][cs] = "cs_" + str(cs)
        if updated:
            joblib.dump(self.data, "data/cs_ext_dict")
            self.data.update(data)
  
    def get_cs_ext_vector(self,tls):
        cs_vector=[]
        ext_vector=[]
        for key in self.data['cs']:
            if key in tls['cs']:
                cs_vector.append(1)
            else:
                cs_vector.append(0)
        cs_vector.extend([0]*(100-len(cs_vector)))
        for key in self.data['ext']:
            if key in tls['c_extensions']:
                ext_vector.append(1)
            else:
                ext_vector.append(0)
        ext_vector.extend([0]*(50-len(ext_vector)))
        return cs_vector,ext_vector

# SSL/TLS特征
# Note: for 异常处理
def get_ssl_tls_feature(session_pcap, TLSPD):

    pkt_num =0
    tls_num =0
    bytes_dict=[] 
    pkt_len = []  # packet length
    tls_len = []  # tls length
    # get tls duration
    for p in session_pcap:
        pkt_num += 1  # Session中packet NO.
        #print("\n", "-" * 15, "Packet: %d" % pkt_num, "-" * 15)
        # packet decode
        data_result_dict = TLSPD.ether_decode(p)
        try:
            data_result_dict['IP']['TCP']
        except :
            #traceback.print_exc()
            continue
        sa=data_result_dict['IP']['sa'] 
        da=data_result_dict['IP']['da'] 
        sp=data_result_dict['IP']['sp'] 
        dp=data_result_dict['IP']['dp']
        pkt_len.append(data_result_dict['len'])
        bytes_dict+=(data_result_dict['IP']['TCP']['bytes'])
        # return tls info
        try:
            data_result_dict['IP']['TCP']['TLS']
        except KeyError:
            #traceback.print_exc()
            tls_len.append(0)
        else:
            tls_num += 1
            
            if 'tls_error' in data_result_dict['IP']['TCP']['TLS']:
                continue
            tls_len.append(data_result_dict['IP']['TCP']['TLS']['tls_len'])

            if data_result_dict['IP']['TCP']['TLS']['tls_step'] == 1:
                TLSPD.update_data(data_result_dict['IP']['TCP']['TLS'])
                cs_vector,ext_vector = TLSPcapDecode.get_cs_ext_vector(TLSPD,data_result_dict['IP']['TCP']['TLS'])
                
            elif data_result_dict['IP']['TCP']['TLS']['tls_step'] == 2:
                tls_cip = data_result_dict['IP']['TCP']['TLS']['tls_cip']
                tls_comp = data_result_dict['IP']['TCP']['TLS']['tls_comp']
                tls_extlen = data_result_dict['IP']['TCP']['TLS']['tls_extlen']
                tls_exttype = data_result_dict['IP']['TCP']['TLS']['tls_exttype']

    try:
        return sa,da,sp,dp, pkt_len, tls_num, tls_len, tls_cip, tls_comp, tls_extlen, tls_exttype,bytes_dict,cs_vector,ext_vector
    except:
        #traceback.print_exc()
        return False

#TCP字节流分布
def get_bytes_dist_features(bytes_dict):
    mean=0
    std = 0
    bytes_dist=pd.Series(bytes_dict)
    bytes_dist=bytes_dist.value_counts(normalize=True).sort_index(ascending=True)
    entropy=stats.entropy(bytes_dist.values, base=2)
    for hex, prob in bytes_dist.items():
        index = int(hex,16)
        mean+=index*prob
        std+=index**2*prob
    std-=mean**2  
    std=std**0.5
    return entropy,mean,std


# 会话流统计特征
def get_session_statistic_feature(session_pcap, TLSPD):
    get_feature = []
    try :
        sa,da,sp,dp, pkt_len, tlss_cnt, tls_len, tls_cip, tls_comp, tls_extlen, tls_exttype, bytes_dict,cs_vector,ext_vector= get_ssl_tls_feature(session_pcap,TLSPD)
    except TypeError:
        #traceback.print_exc()
        return False
    
    get_feature.append(sa)
    get_feature.append(da)
    get_feature.append(sp)
    get_feature.append(dp)
    
    pkts_cnt = len(session_pcap)  # 数据包数量
    get_feature.append(pkts_cnt)
    
    if pkts_cnt:
        sessn_dur = session_pcap[pkts_cnt - 1].time - session_pcap[0].time  # Session持续时间
        get_feature.append(sessn_dur)
    total_bytes = sum(pkt_len)  # Session总字节数
    get_feature.append(total_bytes)
    pkts_len_avg = total_bytes / (pkts_cnt - 3)  # pactet包长平均值，排除tcp三次握手
    get_feature.append(pkts_len_avg)
    total_bytes_tls = sum(tls_len)  # tls总字节数
    get_feature.append(total_bytes_tls)
    tlss_len_avg = total_bytes_tls / tlss_cnt
    get_feature.append(tlss_len_avg)
    get_feature.append(tls_cip)
    get_feature.append(tls_comp)
    get_feature.append(tls_extlen)
    get_feature.append(tls_exttype)
    get_feature.append(cs_vector)
    get_feature.append(ext_vector)   
    
    entropy,mean,std=get_bytes_dist_features(bytes_dict)
    get_feature.append(mean)
    get_feature.append(std)  
    get_feature.append(entropy)
    return get_feature
